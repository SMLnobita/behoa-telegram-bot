import telebot
import os
import time
import keywords
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton, ForceReply
from config import Config, MessageLimits
from models import UserState
from enums import UserStage
from trackers.currency_tracker import CurrencyExchangeTracker
from trackers.gold_tracker import GoldPriceTracker
from trackers.crypto_tracker import CryptoPriceTracker
from utils.message_handler import MessageHandler
from utils.openai_handler import OpenAIHandler

class TelegramBot:
    def __init__(self):
        self.bot = telebot.TeleBot(Config.TELEGRAM_BOT_TOKEN)
        self.openai_handler = OpenAIHandler()
        self.gold_tracker = GoldPriceTracker()
        self.currency_tracker = CurrencyExchangeTracker()
        self.crypto_tracker = CryptoPriceTracker()
        self.users = {}

        if not os.path.exists(Config.HISTORY_DIR):
            os.makedirs(Config.HISTORY_DIR)

        self.bot.set_my_commands([
            telebot.types.BotCommand("start", "Kh·ªüi ƒë·ªông bot"),
            telebot.types.BotCommand("help", "Xem h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng"),
            telebot.types.BotCommand("clear", "X√≥a l·ªãch s·ª≠ chat"),
            telebot.types.BotCommand("time", "Xem th·ªùi gian hi·ªán t·∫°i"),
            telebot.types.BotCommand("info", "Xem th√¥ng tin c·ªßa b·∫°n"),
            telebot.types.BotCommand("image", "T·∫°o h√¨nh ·∫£nh t·ª´ m√¥ t·∫£"),
            telebot.types.BotCommand("vang", "Xem gi√° v√†ng SJC v√† PNJ"),
            telebot.types.BotCommand("ngoaite", "Xem t·ª∑ gi√° ngo·∫°i t·ªá"),
            telebot.types.BotCommand("tienao", "Xem gi√° ti·ªÅn ·∫£o")
        ])

        self._register_handlers()

    def _can_send_message(self, user_state):
        """Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ th·ªÉ g·ª≠i tin nh·∫Øn kh√¥ng"""
        current_time = time.time()
        if current_time - user_state.last_message_time < MessageLimits.COOLDOWN:
            return False
        return True

    def _check_message_limit(self, user_state):
        """Ki·ªÉm tra gi·ªõi h·∫°n tin nh·∫Øn d·ª±a tr√™n tr·∫°ng th√°i"""
        count = user_state.message_count
        stage = user_state.stage

        if stage == UserStage.INITIAL and count >= MessageLimits.INITIAL_LIMIT:
            return False
        elif stage == UserStage.EXTENDED and count >= MessageLimits.EXTENDED_LIMIT:
            return False
        elif stage == UserStage.KEY_USED and count >= MessageLimits.FINAL_LIMIT:
            return False
        return True

    def _clear_user_data(self, user_id):
        """X√≥a to√†n b·ªô d·ªØ li·ªáu c·ªßa ng∆∞·ªùi d√πng"""
        MessageHandler.clear_chat_history(user_id)
        self.users[user_id] = UserState()

    def _get_user_state(self, user_id):
        """L·∫•y ho·∫∑c t·∫°o m·ªõi tr·∫°ng th√°i ng∆∞·ªùi d√πng"""
        if user_id not in self.users:
            self.users[user_id] = UserState()
        return self.users[user_id]

    def _register_handlers(self):
        """ƒêƒÉng k√Ω t·∫•t c·∫£ c√°c handlers cho bot"""
        self.bot.message_handler(commands=['start'])(self.start_message)
        self.bot.message_handler(commands=['help'])(self.help_message)
        self.bot.message_handler(commands=['info'])(self.info_message)
        self.bot.message_handler(commands=['image'])(self.image_message)
        self.bot.message_handler(commands=['clear'])(self.clear_message)
        self.bot.message_handler(commands=['time'])(self.time_message)
        self.bot.message_handler(commands=['vang'])(self.gold_price_message)
        self.bot.message_handler(commands=['ngoaite'])(self.exchange_rate_message)
        self.bot.message_handler(commands=['tienao'])(self.crypto_price_message)
        self.bot.callback_query_handler(func=lambda call: True)(self.callback_handler)
        self.bot.message_handler(func=lambda message: True)(self.handle_message)

    def callback_handler(self, call):
        """X·ª≠ l√Ω callback t·ª´ c√°c n√∫t"""
        user_id = call.message.chat.id
        user_state = self._get_user_state(user_id)

        if call.data == "start":
            self.bot.send_message(user_id, "üí¨ H√£y b·∫Øt ƒë·∫ßu chat!")
            
        elif call.data == "clear":
            self._clear_user_data(user_id)
            self.bot.send_message(
                user_id,
                "üßπ **L·ªãch s·ª≠ chat ƒë√£ ƒë∆∞·ª£c x√≥a!** B·∫°n c√≥ th·ªÉ ti·∫øp t·ª•c chat m·ªõi.",
                parse_mode="Markdown"
            )
            
        elif call.data == "continue" and user_state.stage == UserStage.INITIAL:
            user_state.stage = UserStage.EXTENDED
            remaining = MessageLimits.EXTENDED_LIMIT - user_state.message_count
            self.bot.send_message(
                user_id, 
                f"‚ú® B·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p th√™m {remaining} tin nh·∫Øn!"
            )
            
        elif call.data == "request_key" and user_state.stage == UserStage.EXTENDED:
            user_state.waiting_for_key = True
            self.bot.send_message(
                user_id,
                "üîë Vui l√≤ng nh·∫≠p key ƒë·ªÉ ƒë∆∞·ª£c c·∫•p th√™m tin nh·∫Øn:",
                reply_markup=ForceReply()
            )

    def clear_message(self, message):
        """X·ª≠ l√Ω l·ªánh /clear"""
        user_id = message.chat.id
        self._clear_user_data(user_id)
        self.bot.send_message(
            user_id,
            "üßπ **L·ªãch s·ª≠ chat ƒë√£ ƒë∆∞·ª£c x√≥a!** B·∫°n c√≥ th·ªÉ ti·∫øp t·ª•c chat m·ªõi.",
            parse_mode="Markdown"
        )

    def crypto_price_message(self, message):
        """X·ª≠ l√Ω l·ªánh /tienao"""
        try:
            crypto_data = self.crypto_tracker.fetch_crypto_prices()
            formatted_message = self.crypto_tracker.format_crypto_prices(crypto_data)
            self.bot.send_message(
                message.chat.id,
                formatted_message,
                parse_mode="Markdown"
            )
        except Exception as e:
            error_message = f"‚ùå {str(e)}"
            self.bot.send_message(
                message.chat.id,
                error_message,
                parse_mode="Markdown"
            )

    def image_message(self, message):
        """X·ª≠ l√Ω l·ªánh /image"""
        user_id = message.chat.id
        user_state = self._get_user_state(user_id)

        # Ki·ªÉm tra gi·ªõi h·∫°n tin nh·∫Øn v√† th·ªùi gian ch·ªù
        if not self._can_send_message(user_state):
            self.bot.reply_to(
                message,
                "‚è≥ **ƒê·ª£i m·ªôt ch√∫t r·ªìi t·∫°o ·∫£nh ti·∫øp nh√©!**",
                parse_mode="Markdown"
            )
            return

        if not self._check_message_limit(user_state):
            menu = MessageHandler.create_menu_markup(user_state)
            message_text = "‚ö†Ô∏è **B·∫°n ƒë√£ ƒë·∫°t gi·ªõi h·∫°n tin nh·∫Øn cho giai ƒëo·∫°n n√†y!**"
            
            if user_state.stage == UserStage.INITIAL:
                message_text += "\nNh·∫•n 'Ti·∫øp t·ª•c nh·∫Øn' ƒë·ªÉ ƒë∆∞·ª£c c·∫•p th√™m tin nh·∫Øn."
            elif user_state.stage == UserStage.EXTENDED:
                message_text += "\nNh·∫≠p key ƒë·ªÉ ƒë∆∞·ª£c c·∫•p th√™m tin nh·∫Øn."
            
            self.bot.reply_to(
                message,
                message_text,
                parse_mode="Markdown",
                reply_markup=menu
            )
            return

        try:
            # Extract prompt from message
            if len(message.text.split()) < 2:
                self.bot.reply_to(
                    message,
                    "‚ö†Ô∏è Vui l√≤ng nh·∫≠p m√¥ t·∫£ h√¨nh ·∫£nh sau l·ªánh /image\n" +
                    "V√≠ d·ª•: `/image m·ªôt ch√∫ m√®o ƒëang ng·ªß`",
                    parse_mode="Markdown"
                )
                return

            prompt = " ".join(message.text.split()[1:])
            
            # Send "processing" message
            processing_msg = self.bot.reply_to(
                message,
                "üé® **ƒêang t·∫°o h√¨nh ·∫£nh...**\n" +
                "‚è≥ Vui l√≤ng ƒë·ª£i trong gi√¢y l√°t!",
                parse_mode="Markdown"
            )

            # Generate image
            image_url = self.openai_handler.generate_image(prompt)
            
            if image_url:
                # C·∫≠p nh·∫≠t s·ªë l∆∞·ª£t chat
                user_state.last_message_time = time.time()
                user_state.message_count += 1
                
                # T√≠nh s·ªë tin nh·∫Øn c√≤n l·∫°i
                remaining = MessageHandler.get_remaining_messages(user_state)
                
                # Download and send image
                self.bot.delete_message(message.chat.id, processing_msg.message_id)
                self.bot.send_photo(
                    message.chat.id,
                    image_url,
                    caption=f"üé® *H√¨nh ·∫£nh ƒë∆∞·ª£c t·∫°o t·ª´ m√¥ t·∫£:*\n`{prompt}`\n\nüí¨ B·∫°n c√≤n {remaining} tin nh·∫Øn.",
                    parse_mode="Markdown",
                    reply_to_message_id=message.message_id
                )
            else:
                raise Exception("Kh√¥ng th·ªÉ t·∫°o h√¨nh ·∫£nh")

        except Exception as e:
            error_message = f"‚ùå L·ªói khi t·∫°o h√¨nh ·∫£nh: {str(e)}"
            self.bot.edit_message_text(
                error_message,
                chat_id=message.chat.id,
                message_id=processing_msg.message_id,
                parse_mode="Markdown"
            )

    def exchange_rate_message(self, message):
        """X·ª≠ l√Ω l·ªánh /ngoaite"""
        try:
            rates = self.currency_tracker.fetch_exchange_rates()
            formatted_message = self.currency_tracker.format_exchange_rates(rates)
            self.bot.send_message(
                message.chat.id,
                formatted_message,
                parse_mode="Markdown"
            )
        except Exception as e:
            error_message = f"‚ùå {str(e)}"
            self.bot.send_message(
                message.chat.id,
                error_message,
                parse_mode="Markdown"
            )

    def gold_price_message(self, message):
        """X·ª≠ l√Ω l·ªánh /vang"""
        try:
            gold_data = self.gold_tracker.fetch_gold_prices()
            formatted_message = self.gold_tracker.format_gold_prices(gold_data)
            self.bot.send_message(
                message.chat.id,
                formatted_message,
                parse_mode="Markdown"
            )
        except Exception as e:
            error_message = f"‚ùå {str(e)}"
            self.bot.send_message(
                message.chat.id,
                error_message,
                parse_mode="Markdown"
            )

    def handle_message(self, message):
        """X·ª≠ l√Ω tin nh·∫Øn t·ª´ ng∆∞·ªùi d√πng"""
        user_id = message.chat.id
        user_state = self._get_user_state(user_id)

        if user_state.waiting_for_key:
            if message.text == MessageLimits.VALID_KEY:
                user_state.stage = UserStage.KEY_USED
                user_state.waiting_for_key = False
                remaining = MessageLimits.FINAL_LIMIT - user_state.message_count
                self.bot.send_message(
                    user_id, 
                    f"‚úÖ Key h·ª£p l·ªá! B·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p th√™m {remaining} tin nh·∫Øn."
                )
                return
            else:
                user_state.waiting_for_key = False
                self.bot.send_message(user_id, "‚ùå Key kh√¥ng h·ª£p l·ªá! Vui l√≤ng th·ª≠ l·∫°i sau.")
                return

        if not self._can_send_message(user_state):
            self.bot.send_message(
                user_id,
                "‚è≥ **ƒê·ª£i m·ªôt ch√∫t r·ªìi h·ªèi ti·∫øp nh√©!**",
                parse_mode="Markdown"
            )
            return

        if not self._check_message_limit(user_state):
            menu = MessageHandler.create_menu_markup(user_state)
            message_text = "‚ö†Ô∏è **B·∫°n ƒë√£ ƒë·∫°t gi·ªõi h·∫°n tin nh·∫Øn cho giai ƒëo·∫°n n√†y!**"
            
            if user_state.stage == UserStage.INITIAL:
                message_text += "\nNh·∫•n 'Ti·∫øp t·ª•c nh·∫Øn' ƒë·ªÉ ƒë∆∞·ª£c c·∫•p th√™m tin nh·∫Øn."
            elif user_state.stage == UserStage.EXTENDED:
                message_text += "\nNh·∫≠p key ƒë·ªÉ ƒë∆∞·ª£c c·∫•p th√™m tin nh·∫Øn."
            
            self.bot.send_message(
                user_id,
                message_text,
                parse_mode="Markdown",
                reply_markup=menu
            )
            return
        
        #behoa
        text = message.text.lower()

        if any(keyword in text for keyword in keywords.gold_keywords):
            return self.gold_price_message(message)

        if any(keyword in text for keyword in keywords.name_keywords):
            return self.bot.send_message(
            user_id,
            "ü§ñ **M√¨nh l√† B√©Ho√†-4o, m·ªôt chatbot AI s·ª≠ d·ª•ng GPT-4o!**",
            parse_mode="Markdown"
            )

        if any(keyword in text for keyword in keywords.ngoaite_keywords):
            return self.exchange_rate_message(message)

        if any(keyword in text for keyword in keywords.thoigian_keywords):
            return self.time_message(message)

        if any(keyword in text for keyword in keywords.tienao_keywords):
            return self.crypto_price_message(message)
        
        if any(keyword in text for keyword in keywords.taohoa_keywords):
            return self.bot.send_message(
            user_id,
            "ü§ñ **M√¨nh l√† B√©Ho√†-4o, m·ªôt chatbot AI s·ª≠ d·ª•ng GPT-4o!**\n"
            "ü§ñ **M√¨nh ƒë∆∞·ª£c t·∫°o ra b·ªüi @smlnobita!**",
            parse_mode="Markdown"
            )
        #behoa

        user_state.last_message_time = time.time()
        user_state.message_count += 1

        chat_history = MessageHandler.get_chat_history(user_id)
        messages = [{"role": "system", "content": "B·∫°n l√† m·ªôt chatbot AI s·ª≠ d·ª•ng GPT-4o."}]

        for chat in chat_history:
            if ": " in chat:
                try:
                    role, content = chat.split(": ", 1)
                    if role in ["user", "assistant", "system"]:
                        messages.append({"role": role, "content": content})
                except ValueError:
                    continue

        messages.append({"role": "user", "content": message.text})
        MessageHandler.add_to_chat_history(user_id, "user", message.text)

        time_info = MessageHandler.format_time_message()
        reply = self.openai_handler.process_message(messages, time_info)
        MessageHandler.add_to_chat_history(user_id, "assistant", reply)

        remaining = MessageHandler.get_remaining_messages(user_state)
        remaining_msg = f"\n\nüí¨ B·∫°n c√≤n {remaining} tin nh·∫Øn."
        
        menu = MessageHandler.create_menu_markup(user_state)
        full_reply = f"{reply}{remaining_msg}"
        
        if menu:
            self.bot.send_message(
                user_id, 
                full_reply, 
                parse_mode="Markdown",
                reply_markup=menu
            )
        else:
            self.bot.send_message(
                user_id, 
                full_reply, 
                parse_mode="Markdown"
            )

    def help_message(self, message):
        """X·ª≠ l√Ω l·ªánh /help"""
        help_text = (
            "ü§ñ **H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng B√©Ho√†-4o Bot**\n\n"
            "**üìù C√°c l·ªánh c∆° b·∫£n:**\n"
            "‚Ä¢ `/start` - Kh·ªüi ƒë·ªông bot v√† x√≥a l·ªãch s·ª≠ chat\n"
            "‚Ä¢ `/help` - Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng\n"
            "‚Ä¢ `/clear` - X√≥a l·ªãch s·ª≠ chat hi·ªán t·∫°i\n"
            "‚Ä¢ `/time` - Xem th·ªùi gian hi·ªán t·∫°i\n"
            "‚Ä¢ `/info` - Xem th√¥ng tin c·ªßa b·∫°n\n\n"
            "**üíπ Tra c·ª©u gi√°:**\n"
            "‚Ä¢ `/vang` - Xem gi√° v√†ng SJC v√† PNJ\n"
            "‚Ä¢ `/ngoaite` - Xem t·ª∑ gi√° ngo·∫°i t·ªá Vietcombank\n"
            "‚Ä¢ `/tienao` - Xem gi√° ti·ªÅn ·∫£o tr√™n Binance\n\n"
            "**üé® T·∫°o h√¨nh ·∫£nh:**\n"
            "‚Ä¢ S·ª≠ d·ª•ng `/image <m√¥ t·∫£>` ƒë·ªÉ t·∫°o h√¨nh ·∫£nh\n"
            "‚Ä¢ V√≠ d·ª•: `/image m·ªôt ch√∫ m√®o ƒëang ng·ªß`\n\n"
            "**üí¨ Gi·ªõi h·∫°n chat:**\n"
            f"‚Ä¢ Giai ƒëo·∫°n 1: {MessageLimits.INITIAL_LIMIT} tin nh·∫Øn\n"
            f"‚Ä¢ Giai ƒëo·∫°n 2: {MessageLimits.EXTENDED_LIMIT} tin nh·∫Øn (sau khi nh·∫•n 'Ti·∫øp t·ª•c nh·∫Øn')\n"
            f"‚Ä¢ Giai ƒëo·∫°n 3: {MessageLimits.FINAL_LIMIT} tin nh·∫Øn (sau khi nh·∫≠p key)\n"
            f"‚Ä¢ Th·ªùi gian ch·ªù gi·ªØa c√°c tin nh·∫Øn: {MessageLimits.COOLDOWN} gi√¢y\n\n"
            "**üîç L∆∞u √Ω:**\n"
            "‚Ä¢ li√™n h·ªá: @smlnobita (Telegram)\n"
            "‚Ä¢ Bot c√≥ th·ªÉ hi·ªÉu v√† tr·∫£ l·ªùi b·∫±ng nhi·ªÅu ng√¥n ng·ªØ\n"
            "‚Ä¢ L·ªãch s·ª≠ chat s·∫Ω ƒë∆∞·ª£c l∆∞u cho ƒë·∫øn khi b·∫°n x√≥a ho·∫∑c kh·ªüi ƒë·ªông l·∫°i\n"
            "‚Ä¢ C√≥ th·ªÉ s·ª≠ d·ª•ng n√∫t menu ƒë·ªÉ th·ª±c hi·ªán c√°c thao t√°c nhanh"
        )
        
        self.bot.send_message(
            message.chat.id,
            help_text,
            parse_mode="Markdown"
        )

    def info_message(self, message):
        """X·ª≠ l√Ω l·ªánh /info"""
        try:
            user = message.from_user
            info = (
                "‚ú® **TH√îNG TIN NG∆Ø·ªúI D√ôNG** ‚ú®\n\n"
                f"üÜî **ID:** `{user.id}`\n"
                f"üë§ **Username:** @{user.username if user.username else 'Kh√¥ng c√≥'}\n"
                f"üìõ **T√™n:** {user.first_name} {user.last_name if user.last_name else ''}\n"
                f"üåê **Ng√¥n ng·ªØ:** {user.language_code if user.language_code else 'Kh√¥ng x√°c ƒë·ªãnh'}\n"
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                "üìå H√£y l∆∞u l·∫°i th√¥ng tin n√†y n·∫øu c·∫ßn thi·∫øt!"
            )

            self.bot.send_message(
                message.chat.id,
                info,
                parse_mode="Markdown"
            )
        except Exception as e:
            error_message = (
                "üö® **L·ªñI!** üö®\n"
                f"‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin do l·ªói sau:\n"
                f"`{str(e)}`\n\n"
                "‚öôÔ∏è Vui l√≤ng th·ª≠ l·∫°i sau!"
            )
            self.bot.send_message(
                message.chat.id,
                error_message,
                parse_mode="Markdown"
            )

    def run(self):
        """Kh·ªüi ch·∫°y bot"""
        print("üöÄ Chatbot GPT-4o tr√™n Telegram ƒëang ch·∫°y...")
        print(f"‚è∞ Kh·ªüi ƒë·ªông l√∫c: {MessageHandler.format_time_message()}")
        self.bot.polling()

    def start_message(self, message):
        """X·ª≠ l√Ω l·ªánh /start"""
        user_id = message.chat.id
        self._clear_user_data(user_id)
        
        text = (
            "ü§ñ **Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi B√©Ho√†-4o tr√™n Telegram!**\n\n"
            f"{MessageHandler.format_time_message()}\n\n"
            "üîπ B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu chat ngay.\n"
            "üîπ S·ª≠ d·ª•ng `/help` ƒë·ªÉ xem h∆∞·ªõng d·∫´n chi ti·∫øt.\n"
            "üîπ L·ªãch s·ª≠ chat s·∫Ω ƒë∆∞·ª£c l∆∞u, nh∆∞ng s·∫Ω b·ªã x√≥a khi b·∫°n nh·∫≠p `/start`.\n\n"
            "**üìå C√°c l·ªánh th∆∞·ªùng d√πng:**\n"
            "‚Ä¢ G√µ tin nh·∫Øn b·∫•t k·ª≥ ƒë·ªÉ t√¥i tr·∫£ l·ªùi\n"
            "‚Ä¢ `/help` - Xem h∆∞·ªõng d·∫´n ƒë·∫ßy ƒë·ªß\n"
            "‚Ä¢ `/clear` - X√≥a l·ªãch s·ª≠ chat\n"
            "‚Ä¢ `/time` - Xem th·ªùi gian hi·ªán t·∫°i\n"
            "‚Ä¢ `/vang` - Xem gi√° v√†ng SJC v√† PNJ\n"
            "‚Ä¢ `/ngoaite` - Xem t·ª∑ gi√° ngo·∫°i t·ªá\n"
            "‚Ä¢ `/tienao` - Xem gi√° ti·ªÅn ·∫£o\n"
            "‚Ä¢ `/image <m√¥ t·∫£>` ƒë·ªÉ t·∫°o h√¨nh ·∫£nh\n"
            "‚Ä¢ `/info` - Xem th√¥ng tin c·ªßa b·∫°n\n" 
            "li√™n h·ªá: @smlnobita (Telegram)\n\n"
            "üöÄ **H√£y b·∫Øt ƒë·∫ßu tr√≤ chuy·ªán ngay!**"
        )
        
        markup = InlineKeyboardMarkup(row_width=2)
        markup.add(
            InlineKeyboardButton("üöÄ B·∫Øt ƒë·∫ßu", callback_data="start"),
            InlineKeyboardButton("üßπ X√≥a l·ªãch s·ª≠", callback_data="clear")
        )
        
        self.bot.send_message(message.chat.id, text, parse_mode="Markdown", reply_markup=markup)

    def time_message(self, message):
        """X·ª≠ l√Ω l·ªánh /time"""
        self.bot.send_message(
            message.chat.id,
            MessageHandler.format_time_message(),
            parse_mode="Markdown"
        )

if __name__ == "__main__":
    bot = TelegramBot()
    bot.run()
